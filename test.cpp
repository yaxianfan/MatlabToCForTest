#include<iostream>
#include<vector>
using namespace std;

#define M_PI acos(-1)
//快速傅里叶变换fft
void fft(double* real, double* imag, double* outReal, double* outImage, int size) {
    const double PI = acos(-1.0);
    /*
        real：向量实部
        imag：向量虚部
        这里仅实现对向量的快速傅里叶变换：Y = fft(X)
        计算公式可见matlab关于fft的介绍

        Y(k) = n∑(j=1) X(j)*Wn^(j-1)(k-1)
        X(j) = n∑(k=1)Y(k)*Wn^(j-1)(k-1)
        其中 Wn = e^((-2πi)/n) = cos(-2π/n)+sin(-2π/n)i
    */
    /*double* outReal;
    outReal = (double*)malloc(sizeof(double) * size);
    double* outImage;
    outImage = (double*)malloc(sizeof(double) * size);*/
    
    for (size_t i = 0; i < size; i++)
    {
        outReal[i] = 0;
        outImage[i] = 0;
    }
    double fixed_factor = (-2 * PI) / size;
    for (int u = 0; u < size; u++) {
        double uxf = u * fixed_factor;
        for (int x = 0; x < size; x++) {
            //X(j)*Wn^(j-1)(k-1)
            double power = uxf * x;
            double temp = imag[x] * sin(power);
            outReal[u] += real[x] * cos(power) - temp;
            outImage[u] += real[x] * sin(power) + temp;
        }
    }

    
}
/*
int main()
{
    int size = 256;
    double a[256] = { 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000,  33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 33142.9296875000, 34164, 33459, 30748, 30181, 33926, 40407, 44504,39899, 28207, 16162, 13712, 24822, 41891,56983, 56901, 41014, 20750, 6813, 10172, 28109, 46454, 55443, 51166, 36801, 22996, 17350,21201, 29140, 37654, 41808, 41833 };
    double b[256] = {0};
    double* real = a;
    double* image = b;
    double* outReal = nullptr;
    outReal = (double*)malloc(sizeof(double) * size);
    double* outImage = nullptr;
    outImage = (double*)malloc(sizeof(double) * size);

    cout << "real------------------" << endl;
    for (size_t i = 225; i < size; i++)
    {
        cout << real[i] << " ";
    }
    cout << endl;

    cout << "image------------------" << endl;
    for (size_t i = 0; i < size; i++)
    {
        cout << image[i] << " ";
    }
    cout << endl;

    fft(real, image, outReal, outImage, size);

    cout << "outReal------------" << endl;
    for (size_t i = 0; i < size; i++)
    {
        cout << outReal[i] << " ";
    }
    cout << endl;

    cout << "outImage------------" << endl;for (size_t i = 0; i < size; i++)
    {
        cout << outImage[i] << " ";
    }
    cout << endl;
    cout << "done" << endl;

} */

void unwrap_array(double* in, double* out, int len) {
    out[0] = in[0];
    for (int i = 1; i < len; i++) {
        double d = in[i] - in[i - 1];
        d = d > M_PI ? d - 2 * M_PI : (d < -M_PI ? d + 2 * M_PI : d);
        out[i] = out[i - 1] + d;
    }
}

double pairwiseUnwrap(double phase1, double phase2) {
    while (fabs(phase1 - phase2) > M_PI) {

        if (phase1 > phase2 + M_PI) {
            phase1 = phase1 - 2 * M_PI;
        }
        else if (phase1 < phase2 - M_PI) {
            phase1 = phase1 + 2 * M_PI;
        }
        else {
            break;
        }

    }
    double result = phase1 - phase2;
    return result;
};

bool IsWrap(double phase1, double phase2)
{
    return ((phase1 - phase2) > M_PI || (phase1 - phase2) < -M_PI);
}

double wrapNum(double phase1, double phase2)
{
    if ((phase1 - phase2) > M_PI)
    {
        while (1)
        {
            phase2 = phase2 + 2 * M_PI;
            if ((phase1 - phase2) < M_PI && (phase1 - phase2) > -M_PI)
            {
                break;
            }
        }
    }
    else if ((phase1 - phase2) < -M_PI)
    {
        while (1)
        {
            phase2 = phase2 - 2 * M_PI;
            if ((phase1 - phase2) < M_PI && (phase1 - phase2) > -M_PI)
            {
                break;
            }
        }
    }
    return phase2;
}

//void unwrapVec(double* vec, int size)
//{
//    for (size_t i = 1; i < size; i++)
//    {
//        vec[i] = wrapNum(vec[i - 1], vec[i]);
//    }
//}
void unwrapVec(double* vec, int size)
{
    for (size_t i = 1; i < size; i++)
    {
        //vec[i] = wrapNum(vec[i - 1], vec[i]);
        if ((vec[i - 1] - vec[i]) > M_PI)
        {
            while (1)
            {
                vec[i] = vec[i] + 2 * M_PI;
                if ((vec[i - 1] - vec[i]) < M_PI && (vec[i - 1] - vec[i]) > -M_PI)
                {
                    break;
                }
            }
        }
        else if ((vec[i - 1] - vec[i]) < -M_PI)
        {
            while (1)
            {
                vec[i] = vec[i] - 2 * M_PI;
                if ((vec[i - 1] - vec[i]) < M_PI && (vec[i - 1] - vec[i]) > -M_PI)
                {
                    break;
                }
            }
        }
    }
}
int main()
{
    double* aa = nullptr;
    aa = (double*)malloc(sizeof(double) * 6);
    aa[0] = -12;
    aa[1] = 22;
    aa[2] = 35;
    aa[3] = 1;
    aa[4] = 19;
    aa[5] = -0.8;
    unwrapVec(aa, 6);
    for (size_t i = 0; i < 6; i++)
    {
        cout << aa[i] << endl;
    }

    //double res = wrapNum(1, 1);

    
    //cout << res << endl;
}